##### Переменные – зачем нужны, что такое тип, какие типы бывают
Переменные - это просто имя для для области памяти, в которой мы хотим хранить данные определенного типа. Тип данных говорит о том, какой размер будет у области памяти, что мы можем делать с ней и что не можем. Типа могут быть примитивными, уже определенные языком(например `int`, `char`, `double`), и могут быть определены пользователем(при помощи `typedef` или при создании нового класса).

##### Экземпляр класса. Создание и удаление экземпляра класса. 

Экземпляр - это уже сконструированный объект класса. Для понимания можно взять аналогию с тем, что определение класса - это просто чертеж, а экземпляр класса - это уже собранный объект.

```c++
// Это определенние класса
class Box{
	double length;
    double breadth;
    double height;
}

int main() {
	// А это экземпляр класса
	Box Box1;
}
```

Создается объект класса при помощи конструктра класса. Конструктор класса - это особая функция класса, которая вызывается при его создании. Конструктор выглядит как функция с таким же именем, что и класс. Также он не имеет типа. 
Класс может иметь нексколько конструкторов с разными количеством и типами аргументов. Компилятор сам поймет какой вызывать.

```c++
class Box {
	double length;
	double breadth;
	double height;

	// Конструктор без аргументов
	Box() {
		length = 1.0;
		breadth = 1.0;
		height = 1.0;
	}

	// Конструктор с аргументами
	Box(double side_lenght) {
		length = side_lenght;
		breadth = side_lenght;
		height = side_lenght;
	}
};
```

Уничтожением класса занимается деструктор. Он как конструктор только наоборот. Конструктор и деструктор, инь и янь, ~~русаков и здравый смысл~~. Задется он почти как конструктор, только в начале добавляется `~`.

```c++
#include <iostream>
using namespace std;

class Box {
	double length;
	double breadth;
	double height;

	// Конструктор без аргументов
	Box() {
		length = 1.0;
		breadth = 1.0;
		height = 1.0;
	}

	// Конструктор с аргументами
	Box(double side_lenght) {
		length = side_lenght;
		breadth = side_lenght;
		height = side_lenght;
	}

	// Деструктор
	~Box() {
		cout << "Мама, я не хоу умирать!" << endl;
	}
};
```

И последнее о чем стоит поговорить - это Трактор. 
БЛЯЯЯЯЯТЬ ТРААКТОР БЛЯЯЯЯЯТЬ БЛЯЯЯЯХААТЬ ТРАААКТОООР ЙУЙ
##### Конструктор копии и оператор присваивания

Конструктор копии, внимание, уонструирует копию объекта. Определяется он как конструктор, которому в качестве аргумента передали ссылку на этот же класс.

```c++
class Box {
	double length;
	double breadth;
	double height;

	// Конструктор
	Box() {
		length = 1.0;
		breadth = 1.0;
		height = 1.0;
	}

	// Конструктор, но холоднее 
	Box(&Box box) {
		// тут мы что-то делаем
		// мне лень писать
	}
```

Да и не так важно, как писать конструктор копирования. Важно знать, когда он вызывается. А вызывается он когда:
- Создается новый экземпляр на основе другого (aka присваиваем переменной значение другой переменной)
- Экземпляр передается в функцию по значению
- Когда мы возвращаем экземпляр из функции по значению
- Когда  делаем ночной звонок тебе, чтобы сказать что чувствуем. Повезем через ночь вниз по холмам. Собираюсь сказать тебе что-то, но ты не хочешь слушать 

##### Методы и функции. Различия и сходства. Возвращаемое значение, параметры.

Функция -> Ассоциированная функция -> Метод

Функция - это просто функция, ее можно вызвать, она может что-то вернуть.
Ассоциированная функция - это член класса. 
А метод - это ассоциированная функция, которая имеет указатель `this`(о нем потом будет вопрос). 

! там еще всякие `static` функции есть, если хотите, почитайте

##### Рекурсия

Рекурсия - это когда функции вызываются рекрсивно.

Ну себя они вызывают. 

Стоит запомнить, что в случае слишком длинной рекурсии программа вылетит, так как произойдет переполнение. Происходит это, потому что при каждом вызове рекурсивной функции процессору нужно знать к какой области памяти необходимо вернуться и он записывает эту область(а еще различные переменные хранятся тут же), потому память на стэке может банально кончиться.

Так же у каждой рекурсивной функции есть краевые условия, при выполнении которых рекусрия прекращается и функция вместо вызова еще одной функции возвращает занчение.

##### Конструктор и деструктор класса. Когда происходит вызов.

Я уже это писал

##### Указатели и ссылки. Особенности работы

Указатель просто указывает на какой-то адрес в памяти.

```c++
// Просто переменная
int a = 5;
// Создаем указатель на перменную
// int* - говорит, что тип переменной - это указатель на int
// Оператор & возвращает адресс переменной
int* b = &a;
```

Подсказка: проще всего читать типы справа налево. Например `int** b` разбиваем справа налево как: `b`, `*`, `*`, `int`. И читаем: "Переменная `b` это указатель(`*`) на указатель(`*`) на `int`".

**Ссылка** - это как указатель, только безопаснее.

Чтобы указать, что переменная является ссылкой на переменную, нужно добавить `&`(не путать с оператором взятия адреса, он пишется перед уже сущетвующей переменной, а не в типе при создании).

```c++
int a = 5;
int& b = a;
```

Во-первых обращаться с ссылкой нужно как с обычным объектом, не нужно его разыменовывать.
Во-вторых в отличии от указателя мы не можем поменять на что указывает ссылка.
В-третих ссылка всега является валидной, она не может указывать на `NULL` или на неинициализированную память.

##### Преобразование типов на базовый и производный тип. Расширение и сужение.

Синтаксиса тут не будет, мне лень.

Представим, что у нас есть два класса: родительский - Animal и дочерний - Sheep. 
Сужением будет являться преобразование переменной типа Sheep к переменной типа Animal. Это всегда безопасно, так как у Sheep всегда есть функции и поля необходимые для работы Animal, потому что они наследуются от него же.
Расширением будет являться преобразование переменной Animal в премеиенную типа Sheep. А вот это уже может повлечь за собой ошибки. Прежде чем преобразовывать таким образом мы должны точно знать, что до этого в жтой памяти лежал объект типа Sheep, потому что тогда у нас будет ситуация, когда в памяти нет необходимой информации для корректной работы.

##### Локальные и глобальные переменные. Время жизни

Глобальные переменные - это переменные, объявленные вне функций. Все остальные будут локальными.

```c++
// Глобальная переменная
int A = 5;

void kek() {
	// Локальная переменная
	int c = 0;
}

int main() {
	// Локальная переменная
	int b = 7;
	kek();
}
```

Время жизни переменной определяет когда переменная будет удалена из памяти. В предыдущем примере перменная `A` будеть *жить* всю программу, такое время жизни называют статическое. Перменнная `b` очистится после завершения выполнения `main`, а перменная `c` очиститься после окончания выполнения функции `kek`.

##### Динамическое выделение памяти.

Память можно выделить по ходу работы программы. Для этого в C++ используется оператор `new`(еще можно всякие `malloc` и `calloc`, но суть та же(ну хорошо, не совсем, `new` вызывает конструктор объекта при выделении памяти, а `malloc` и `calloc` просто выделяют кусок памяти определенного размера~~(скобочка)~~)).

```c++
int main()
{
    double* val = NULL;
    val = new double;
    *val = 38184.26;
    delete val;
}
```

Возвращают указатели на выделенную память. Не забывайте ее очищать, иначе память потечет. Очищается при помощи оператора `delete`. 
А еще почитайте про различия `delete` и `delete[]`. В прошлом семаке часто про это спрашивал.

##### Методы класса. Их вызов.

Как я уже писал, тут надо сначала понять, что он считает методом класса. 
Через точку они вызываются.
Должны по крайней мере.
```c++
obj.func();
```

##### Указатель типа void

Ну это прям тупой вопрос. Это просто указатель типа `void`. Просто указатель.
Единственное что его нельзя разыменовать в c++, обязательно нужно привети к какому-то типу.
```c++
void *pv;
int *pint; 
int i = 6; 

int main() { 
	pv = &i;
	pint = (int *)pv; 
}
```

##### Указатель this

Просто указатель на экземпляр класса в функциях.
Почитайте сами, меня эту штука бесит.
Меня вообще плюсы бесят.

##### Переопределение операторов



##### Массивы указателей.

Ой, ну серьезно?
Просто каждый элемент это указатель, ничего особенного, что отличает их от других массивов.

##### Статические массивы, смешанные массивы (многомерные)
То же самое.
Это массив, который хранит в себе массив.

##### Статическое и динамическое выделение памяти
Зачем сначала вопрос про динамическое выделение, а потом вот это?
##### Модификаторы доступа
Существуют `public`, `private` и `protected`.
Модификатор `public` дает доступ всем другим классам, кто видит определение данного класса, `private` - доступ открыт самому классу и друзьям класса(жесть тупо звучит), а `protected` дает доступ классам, производным от данного.

##### Виртуальные функции и наследование. 



##### Доступ по индексу в коллекциях данных. В каких коллекциях присутствует, где работает эффективнее
##### Коллекция вектор, сравнение со статическим и динамическим массивом
##### Итераторы.

##### Бинарный поиск
##### Обход бинарного дерева
##### Организация вставки в дерево
##### Стек, очередь, список
##### Вставка в корень дерева
##### Трудоемкость операций
##### Вращение узлов дерева