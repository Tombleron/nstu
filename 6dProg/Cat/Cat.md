
##### Переменные – зачем нужны, что такое тип, какие типы бывают
Переменные - это просто имя для для области памяти, в которой мы хотим хранить данные определенного типа. Тип данных говорит о том, какой размер будет у области памяти, что мы можем делать с ней и что не можем. Типа могут быть примитивными, уже определенные языком(например `int`, `char`, `double`), и могут быть определены пользователем(при помощи `typedef` или при создании нового класса).

##### Экземпляр класса. Создание и удаление экземпляра класса. 

Экземпляр - это уже сконструированный объект класса. Для понимания можно взять аналогию с тем, что определение класса - это просто чертеж, а экземпляр класса - это уже собранный объект.

```c++
// Это определенние класса
class Box{
	double length;
    double breadth;
    double height;
}

int main() {
	// А это экземпляр класса
	Box Box1;
}
```

Создается объект класса при помощи конструктра класса. Конструктор класса - это особая функция класса, которая вызывается при его создании. Конструктор выглядит как функция с таким же именем, что и класс. Также он не имеет типа. 
Класс может иметь нексколько конструкторов с разными количеством и типами аргументов. Компилятор сам поймет какой вызывать.

```c++
class Box {
	double length;
	double breadth;
	double height;

	// Конструктор без аргументов
	Box() {
		length = 1.0;
		breadth = 1.0;
		height = 1.0;
	}

	// Конструктор с аргументами
	Box(double side_lenght) {
		length = side_lenght;
		breadth = side_lenght;
		height = side_lenght;
	}
};
```

Уничтожением класса занимается деструктор. Он как конструктор только наоборот. Конструктор и деструктор, инь и янь, ~~русаков и здравый смысл~~. Задется он почти как конструктор, только в начале добавляется `~`.

```c++
#include <iostream>
using namespace std;

class Box {
	double length;
	double breadth;
	double height;

	// Конструктор без аргументов
	Box() {
		length = 1.0;
		breadth = 1.0;
		height = 1.0;
	}

	// Конструктор с аргументами
	Box(double side_lenght) {
		length = side_lenght;
		breadth = side_lenght;
		height = side_lenght;
	}

	// Деструктор
	~Box() {
		cout << "Мама, я не хоу умирать!" << endl;
	}
};
```

И последнее о чем стоит поговорить - это Трактор. 
БЛЯЯЯЯЯТЬ ТРААКТОР БЛЯЯЯЯЯТЬ БЛЯЯЯЯХААТЬ ТРАААКТОООР ЙУЙ
##### Конструктор копии и оператор присваивания

Конструктор копии, внимание, уонструирует копию объекта. Определяется он как конструктор, которому в качестве аргумента передали ссылку на этот же класс.

```c++
class Box {
	double length;
	double breadth;
	double height;

	// Конструктор
	Box() {
		length = 1.0;
		breadth = 1.0;
		height = 1.0;
	}

	// Конструктор, но холоднее 
	Box(&Box box) {
		// тут мы что-то делаем
		// мне лень писать
	}
```

Да и не так важно, как писать конструктор копирования. Важно знать, когда он вызывается. А вызывается он когда:
- Создается новый экземпляр на основе другого (aka присваиваем переменной значение другой переменной)
- Экземпляр передается в функцию по значению
- Когда мы возвращаем экземпляр из функции по значению
- Когда  делаем ночной звонок тебе, чтобы сказать что чувствуем. Повезем через ночь вниз по холмам. Собираюсь сказать тебе что-то, но ты не хочешь слушать 

##### Методы и функции. Различия и сходства. Возвращаемое значение, параметры.

Функция -> Ассоциированная функция -> Метод

Функция - это просто функция, ее можно вызвать, она может что-то вернуть.
Ассоциированная функция - это член класса. 
А метод - это ассоциированная функция, которая имеет указатель `this`(о нем потом будет вопрос). 

##### Рекурсия

Рекурсия - это когда функции вызываются рекрсивно.

Ну себя они вызывают. 

Стоит запомнить, что в случае слишком длинной рекурсии программа вылетит, так как произойдет переполнение. Происходит это, потому что при каждом вызове рекурсивной функции процессору нужно знать к какой области памяти необходимо вернуться и он записывает эту область(а еще различные переменные хранятся тут же), потому память на стэке может банально кончиться.

Так же у каждой рекурсивной функции есть краевые условия, при выполнении которых рекусрия прекращается и функция вместо вызова еще одной функции возвращает занчение.

##### Конструктор и деструктор класса. Когда происходит вызов.

Я уже это писал

##### Указатели и ссылки. Особенности работы

Указатель просто указывает на какой-то адрес в памяти.

```c++
// Просто переменная
int a = 5;
// Создаем указатель на перменную
// int* - говорит, что тип переменной - это указатель на int
// Оператор & возвращает адресс переменной
int* b = &a;
```

Подсказка: проще всего читать типы справа налево. Например `int** b` разбиваем справа налево как: `b`, `*`, `*`, `int`. И читаем: "Переменная `b` это указатель(`*`) на указатель(`*`) на `int`".

**Ссылка** - это как указатель, только безопаснее.

Чтобы указать, что переменная является ссылкой на переменную, нужно добавить `&`(не путать с оператором взятия адреса, он пишется перед уже сущетвующей переменной, а не в типе при создании).

```c++
int a = 5;
int& b = a;
```

Во-первых обращаться с ссылкой нужно как с обычным объектом, не нужно его разыменовывать.
Во-вторых в отличии от указателя мы не можем поменять на что указывает ссылка.
В-третих ссылка всега является валидной, она не может указывать на `NULL` или на неинициализированную память.

##### Преобразование типов на базовый и производный тип. Расширение и сужение.

Синтаксиса тут не будет, мне лень.

Представим, что у нас есть два класса: родительский - Animal и дочерний - Sheep. 
Сужением будет являться преобразование переменной типа Sheep к переменной типа Animal. Это всегда безопасно, так как у Sheep всегда есть функции и поля необходимые для работы Animal, потому что они наследуются от него же.
Расширением будет являться преобразование переменной Animal в премеиенную типа Sheep. А вот это уже может повлечь за собой ошибки. Прежде чем преобразовывать таким образом мы должны точно знать, что до этого в жтой памяти лежал объект типа Sheep, потому что тогда у нас будет ситуация, когда в памяти нет необходимой информации для корректной работы.

##### Локальные и глобальные переменные. Время жизни
##### Динамическое выделение памяти.
##### Методы класса. Их вызов.
Лень
##### Указатель типа void
##### Указатель this
##### Переопределение операторов
##### Массивы указателей.
Лень
##### Статические массивы, смешанные массивы (многомерные)
Лень
##### Статическое и динамическое выделение памяти
Лень
##### Модификаторы доступа
##### Виртуальные функции и наследование. 
##### Доступ по индексу в коллекциях данных. В каких коллекциях присутствует, где работает эффективнее
##### Коллекция вектор, сравнение со статическим и динамическим массивом


##### Итераторы.
##### Бинарный поиск
##### Обход бинарного дерева
##### Организация вставки в дерево
##### Стек, очередь, список
##### Вставка в корень дерева
##### Трудоемкость операций
##### Вращение узлов дерева